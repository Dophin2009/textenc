% -----------------------------------------------
% chktex-file 44
\documentclass[../index.tex]{subfiles}

% -----------------------------------------------

\begin{document}

% -----------------------------------------------
\renewcommand{\sectiontitle}{Unicode}
\section{\sectiontitle}
% I hope you found ASCII pretty simple, because it's only going to get more complicated from
% here on out.
%
% Why's that?
% Because language is complicated.

% ---------------------------
\renewcommand{\currenttitle}{The problems with ASCII}
\begin{frame}{\currenttitle}
% Let's review the problems with ASCII again.
% Knowing these shortcomings will help us understand how and why Unicode is designed the way
% it is.
%
% The original ASCII character set only supported the basic English alphabet, the ten Arabic
% numeral digits, some punctuations symbols, and some other unreadable symbols.
% As we've mentioned before, this isn't really going to cut it once you move outside of English.
%
% The extended ASCII character sets like Latin 1 tried to help this, but then we have many
% different widely adopted but largely incompatible character sets.
% When you're transforming data across the globe into different systems using different
% character sets and encodings, this is going to be a problem.
%
% And as we'll see in a brief examination of other languages, the terminology and design
% behind ASCII is too naïve to support many kinds of languages.
  Let's review: \\

  \begin{itemize}
    \item[--] Minimal language support
    \item[--] Variants that are widespread but incompatible
    \item[--] Too naïve for many types of languages
  \end{itemize}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Even more precise terminology}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{How does Unicode define `character'?}
\begin{frame}{\currenttitle}
  ``The smallest component of written language that has semantic value; refers to the
    abstract meaning and/or shape, rather than a specific shape\ldots''
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The Universal Character Set}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The seventeen Unicode planes}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Examining UTF-8 encoding}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Writing a UTF-8 decoder}
\newcommand{\decoderheaderlisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   firstline=#1,lastline=#2]{%
    \subdir/41-utf8-parser.hpp}%
}
\begin{frame}{\currenttitle}
% Let's write a UTF-8 decoder in C++. Don't worry if you don't know any C++, I'll walk through
% most of the code.
%
% We'll write a function convert a vector of UTF-8 encoded bytes into a vector of Unicode
% codepoints.
%
% Note that we won't be preforming any validation, so this is far from production-ready.
% We're simply assuming that the bytes are proper UTF-8.
%
% Here's part of our header file, where we'll define the function signatures and some constants.
%
% This is probably not a good practice, but we're going to alias unsigned char to a type called
% byte, and unsigned int to a type called codepoint.
% In C and C++, chars are 8-bit integers, and unsigned indicates that these values will always
% be positive.
% Thus, a byte, which we've defined as unsigned char, will simply be an 8-bit integer, representing
% an actual byte.
% Ints are 32-bit integers, so unsigned int denotes a positive 32-bit integer.
%
% We've given these names to make it clear that we're converting from a vectory of bytes to a
% vector of codepoints.
  Let's write a UTF-8 decoder in C++ \\

  We'll convert a vector of bytes into Unicode codepoints \\

  \vspace*{2em}

  Our header file:

  \decoderheaderlisting{4}{7}
\end{frame}

% ---------------------------
% Here are the functions we'll be implementing.
%
% Let's look at the second one first.
% If you've ever written Java or any other C-family language, you'll probably realize that
% we've define the function 'decode' that takes in a vector of bytes, of unsigned 8-bit
% integers.
%
% A vector is similar to the ArrayList in Java and list in Python. It's simply a growable,
% ordered container of values.
%
% const lets us know that this function won't be modifying the vector that's passed in.
%
% And vector<codepoint> indicates that the function is returning a vector of codepoints,
% a vector of 32-bit unsigned integers.
%
% 'decode' will be the main function that we call to decode UTF-8 encoded bytes.
%
% Now let's look at the second one. This is a sort of auxilliary function that will help
% 'decode' perform its logic.
%
% We pass in an iterator to a vector of bytes and step through it until we've decoded a
% single codepoint. It'll modify the location of the iterator.
% 'end' is another iterator to the same vector that will tell us inside 'next_codepoint'
% if we've reached the end of the vector and there are no more bytes to process.
%
% 'next_codepoint' is going to return an optional, which is a sum type that contains a
% value or contains null. Think of it as something or nothing.
% We're returning either a codepoint, or we're returning nothing if we're in the middle
% of decoding an codepoint and we run out of bytes to process.
%
% Don't worry too much about some of the other details.
\begin{frame}{\currenttitle}
  Our function signatures:

  \decoderheaderlisting{1}{2}
  \decoderheaderlisting{14}{18}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Here are constants we'll use in 'next_codepoints'. We'll refer back to these later.
  Byte mask constants we'll use to help process each byte:

  \decoderheaderlisting{9}{12}
\end{frame}

% ---------------------------
\newcommand{\decodercodelisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   firstline=#1,lastline=#2]{%
    \subdir/41-utf8-parser.cpp}%
}
\begin{frame}{\currenttitle}
  \decodercodelisting{8}{10}
\end{frame}

% ---------------------------
\begin{frame}[fragile]{\currenttitle}
  \lstinputlisting[language=C++,firstline=10]{\subdir/43-utf8.cpp}

  \vspace*{1em}

  The result:

  \input{\subdir/43-utf8.Rnw_tex}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{UTF-16}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Unicode's shortcomings}
\begin{frame}{\currenttitle}
\end{frame}

% -----------------------------------------------

\end{document}
