% -----------------------------------------------
% chktex-file 44
\documentclass[../index.tex]{subfiles}

% -----------------------------------------------

\begin{document}

% -----------------------------------------------
\renewcommand{\sectiontitle}{Unicode}
\section{\sectiontitle}
% I hope you found ASCII pretty simple, because it's only going to get more complicated from
% here on out.
%
% Why's that?
% Because language is complicated.

% ---------------------------
\renewcommand{\currenttitle}{The problems with ASCII}
\begin{frame}{\currenttitle}
% Let's review the problems with ASCII again.
% Knowing these shortcomings will help us understand how and why Unicode is designed the way
% it is.
%
% The original ASCII character set only supported the basic English alphabet, the ten Arabic
% numeral digits, some punctuations symbols, and some other unreadable symbols.
% As we've mentioned before, this isn't really going to cut it once you move outside of English.
%
% The extended ASCII character sets like Latin 1 tried to help this, but then we have many
% different widely adopted but largely incompatible character sets.
% When you're transforming data across the globe into different systems using different
% character sets and encodings, this is going to be a problem.
%
% And as we'll see in a brief examination of other languages, the terminology and design
% behind ASCII is too na√Øve to support many kinds of languages.
  Let's review: \\

  \begin{itemize}
    \item[--] Minimal language support
    \item[--] Variants that are widespread but incompatible
    \item[--] Too na√Øve for many types of languages
  \end{itemize}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Even more precise terminology}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{How does Unicode define `character'?}
\begin{frame}{\currenttitle}
  ``The smallest component of written language that has semantic value; refers to the
    abstract meaning and/or shape, rather than a specific shape\ldots''
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The Universal Character Set}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The seventeen Unicode planes}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Unicode encodings}
\begin{frame}{\currenttitle}
% Remember that Unicode defines the coded character set by assigning each character
% a codepoint.
% It doesn't specify which encoding you have to use to store these characters.
%
% The standard defines a few encodings, the most common of which are UTF-8 and UTF-16.
%
% The majority of websites are now encoded in UTF-8, and if you use a Unix-based system
% like Linux or macOS, the default encoding is UTF-8.
% For many modern programming languages, the encoding used internally for strings is UTF-8.
% In Rust, every string is handled internally as valid UTF-8.
%
% If you use Microsoft Windows, the default internal encoding is UTF-16.
% Java stores strings as UTF-16 internally.
%
% Of these, you should care the most about UTF-8. It's avoids complications found in
% UTF-16 and UTF-32 and is the most widely used encoding.
% The Web Hypertext Application Technology Working Group considers UTF-8 to be
% best practice and states that any browser application should not use UTF-16.
%
% So, we're going to focus primarily on UTF-8 and discuss UTF-16 briefly at the end.
  The Unicode standard defines a number of encoding formats:

  \begin{itemize}
    \item \textbf{UTF-8} \textendash{} 8-bit Unicode Transformation Format
    \item[] UTF-16LE \textendash{} 16-bit Unicode Transformation Format LE
    \item[] UTF-16BE \textendash{} UTF-16LE, but big-endian
    \item[] UTF-32LE \textendash{} 32-bit Unicode Transformation Format LE
    \item[] UTF-32BE \textendash{} UTF-32LE, but big-endian
  \end{itemize}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Examining UTF-8 encoding}
\begin{frame}{\currenttitle}
% Let's examine how characters are encoded and decoded to and from UTF-8.
%
% UTF-8 is a variable-width encoding, meaning each codepoint can take up a variable
% number of bytes.
% In the case of UTF-8, each codepoint is stored as in 1, 2, 3, or 4 bytes.
% 4 bytes is enough to store every single character in the Universal Character Set.
  UTF-8 is a \textbf{variable-width} encoding \\
  \vspace*{1em}
  Each codepoint is stored in \textbf{1 \textendash{} 4 bytes}

  \vspace*{1em}

  \begin{table}
    \begin{tabular}{c c c}
      Character & Codepoint   & Bytes required  \\ \hline
      \$        & \hex{0024}  & 1               \\
      ¬¢         & \hex{00A2}  & 2               \\
      ‚Ç¨         & \hex{20AC}  & 3               \\
      êçà         & \hex{10348} & 4
    \end{tabular}
    \caption{Number of bytes required to store certain characters}
  \end{table}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Writing a UTF-8 decoder}
\newcommand{\decoderheaderlisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   numbers=left,numbersep=8pt,
                   firstnumber=#1,
                   firstline=#1,lastline=#2]{%
    \codedir/utf8-decoder.hpp}%
}
\begin{frame}{\currenttitle}
% Let's write a UTF-8 decoder in C++. Don't worry if you don't know any C++, I'll walk through
% most of the code.
%
% We'll write a function convert a vector of UTF-8 encoded bytes into a vector of Unicode
% codepoints.
%
% Note that we won't be preforming any validation, so this is far from production-ready.
% We're simply assuming that the bytes are proper UTF-8.
%
% Here's part of our header file, where we'll define the function signatures and some constants.
%
% This is probably not a good practice, but we're going to alias unsigned char to a type called
% byte, and unsigned int to a type called codepoint.
% In C and C++, chars are 8-bit integers, and unsigned indicates that these values will always
% be positive.
% Thus, a byte, which we've defined as unsigned char, will simply be an 8-bit integer, representing
% an actual byte.
% Ints are 32-bit integers, so unsigned int denotes a positive 32-bit integer.
%
% We've given these names to make it clear that we're converting from a vectory of bytes to a
% vector of codepoints.
  Let's write a UTF-8 decoder in C++ \\

  We'll convert a vector of bytes into Unicode codepoints \\

  \vspace*{2em}

  Our header file:
  \vspace*{1em}

  \decoderheaderlisting{4}{7}
\end{frame}

% ---------------------------
% Here are the functions we'll be implementing.
%
% Let's look at the second one first.
% If you've ever written Java or any other C-family language, you'll probably realize that
% we've define the function 'decode' that takes in a vector of bytes, of unsigned 8-bit
% integers.
%
% A vector is similar to the ArrayList in Java and list in Python. It's simply a growable,
% ordered container of values.
%
% const lets us know that this function won't be modifying the vector that's passed in.
%
% And vector<codepoint> indicates that the function is returning a vector of codepoints,
% a vector of 32-bit unsigned integers.
%
% 'decode' will be the main function that we call to decode UTF-8 encoded bytes.
%
% Now let's look at the second one. This is a sort of auxilliary function that will help
% 'decode' perform its logic.
%
% We pass in an iterator to a vector of bytes and step through it until we've decoded a
% single codepoint. It'll modify the location of the iterator.
% 'end' is another iterator to the same vector that will tell us inside 'next_codepoint'
% if we've reached the end of the vector and there are no more bytes to process.
%
% 'next_codepoint' is going to return an optional, which is a sum type that contains a
% value or contains null. Think of it as something or nothing.
% We're returning either a codepoint, or we're returning nothing if we're in the middle
% of decoding an codepoint and we run out of bytes to process.
%
% Don't worry too much about some of the other details.
\begin{frame}{\currenttitle}
  Our function signatures:
  \vspace*{1em}

  \decoderheaderlisting{1}{2}
  \decoderheaderlisting{14}{18}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Here are constants we'll use in 'next_codepoint'. We'll refer back to these later.
  Byte mask constants we'll use to help process each byte:
  \vspace*{1em}

  \decoderheaderlisting{9}{12}
\end{frame}

% ---------------------------
\newcommand{\decodercodelisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   numbers=left,numbersep=8pt,
                   firstnumber=#1,
                   firstline=#1,lastline=#2]{%
    \codedir/utf8-decoder.cpp}%
}
\begin{frame}{\currenttitle}
% We'll start by implementing 'next_codepoint'.
% We'll be mutating the 'iter' iterator by consuming one or more bytes and converting
% it into an integer.
%
% Here we're first checking if we've already reached the end of the bytes.
% If so, we return an empty optional.
% Remember that the optional is like 'something' or 'nothing'.
% In this case, it's nothing.
  Check if the iterator has reached the end; if so, return nothing: \\
  \vspace*{1em}
  \decodercodelisting{8}{13}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Let's start by handling the case where the next codepoint can be stored in a single
% byte.
% These are codepoints with values less than 128.
%
% We'll get the byte value the iterator is currently on and check if it's less than
% 128.
% Remember, this means that the most significant bit will be 0 and thus indicates
% that this codepoint takes up only a single bit.
% It also means that any valid 8-bit ASCII is also valid UTF-8.
%
% So, if it's greater than 128, the codepoint takes up more than a single byte, and
% have to write other code to handle that.
% But if it does happen to be less than 128, we consume the byte from the iterator by
% incrementing it.
% The next time we look at the iterator, it'll be pointing to the next byte value.
%
% Then, we'll simply cast the byte value into an unsigned 32-bit integer and return
% it.
  Handle the 1-byte case: \\
  \vspace*{1em}
  \decodercodelisting{15}{21}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% With the 1-byte case handled, let's handle the case where the codepoint is encoded in
% 2 bytes.
%
% In the 2-byte case, we remember that the first byte will start with the bits 110,
% and the second byte will start with the bits 10.
% That means the first bit must be less than 224, or 0xE0 in hex.
%
% We'll again first check if the iterator has reached the end of the byte stream and
% return nothing if it has.
%
% If not, we'll get the value of the next byte.
% This is the second byte in our 2-byte codepoint.

% We'll check if our first byte is less than 224.
% If so, we again increment the iterator to consume that byte.
%
% Since we're assuming that the byte stream we've been given is valid UTF-8, we're just
% assuming that the second byte starts with the bits 10.
% The next two lines do the decoding of the 2 bytes into a codepoint value.
%
% Remember, we can't simply convert these 2 bytes into integers and add or multiply them.
% When these bytes were encoded, the 5 most significant bits were taken and put in the
% first byte.
%
% We perform a bitwise AND operation on this first byte and the B2_MASK value defined in
% our header.
% This eliminates the leading 110 so we're left with 000 and then our first 5 bits,
% equal to just our first 5 bits.
% Then we cast this value into a unsigned 32-bit integer, so we have 27 leading 0's.
%
% Finally, by shifting the bits by 6 places, we drop the 6 most significant bits of this
% integer (which are all leading 0's) and add 6 least significant bits to the end.
% This leaves us with 6 0's following our 5 bits, and it's in those 6 spaces where we'll
% put the 6 bits decoded from the second byte.
% We store this in acc.
%
% In the next line, we perform another bitwise AND operation, this time on the second byte
% and the MB_MASK value defined in the header.
% We know the first 2 bits of the second byte are 10.
% We only care about the last 6 bits, so this operation eliminates those first two bits
% into 0's.
%
% Finally, the bitwise OR operation with acc puts these 6 bits into their place at the end
% of the codepoint.
% With that, we've successfully decoded the 2-byte case.
  Handle the 2-byte case: \\
  \vspace*{1em}
  \decodercodelisting{24}{35}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Naturally, we next handle the 3-byte case.
%
% We do the same checks and get the value of the third byte.
% Then, since in the 3-byte case, the first byte must start with the bits 1110, we check
% if the first byte is less than 240, or 0xF0.
%
% If so, we consume the iterator and decode these 3 bytes.
%
% Similar to in the 2-byte case, we apply a bit mask using the bitwise AND operator to the
% first byte.
% In this case, our mask is the B3_MASK value we defined earlier rather than B2_MASK.
% This operation turns the four most significant bits, the 1110, into 0's, because we only
% care about the last 4 bits.
% Then, we shift these bits to the left again, except this time by 12 positions.
%
% We know that the second and third bytes will start with the bits 10, so we use the MB_MASK
% again to turn those leading 2 bits into 0's for each byte.
% The second byte's value is shifted left 6 positions and combined with the accumulated
% value.
% Finally, we combine the third byte's value with the accumulator and return the final value.
%
% Thus, we have 4 bits from the first encoded byte, then 6 bits from the second byte, and
% our final 6 bits from the third byte.

  Handle the 3-byte case: \\
  \vspace*{1em}
  \decodercodelisting{38}{50}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Handling the 4-byte case looks very similar to the previous logic.
% Since we're assuming valid UTF-8, if the first bit doesn't start with 0, 110, or 1110, we
% assume that it must start with 11110.
%
% For the first byte, we apply a bit mask again, except this time it's the B4_MASK that
% changes the first 5 bits into 0's.
% Since we have 18 bits (provided by the next three bits) to put at the end of the codepoint
% value, we shift this value by 18 positions.
% For the second, third, and fourth bytes, we use the MB_MASK and shift each value by 12,
% and 6 places.
%
% And with this, we've completed 'next_endpoint'.
  Handle the 4-byte case: \\
  \vspace*{1em}
  \decodercodelisting{52}{66}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Let's put it all together in 'decode'.
%
% Remember that the caller passes in a vector of bytes that they want decoded into codepoint
% values.
%
% We create two iterators that we'll pass into 'next_codepoint', one that points to the start
% of the bytes, and another that points to the end of bytes.
% In a loop, we call 'next_codepoint' repeatedly and append the result of each call to a
% vector that we return at the end of the function.
  Implementing \texttt{decode}: \\
  \vspace*{1em}
  \decodercodelisting{68}{82}
\end{frame}

% ---------------------------
\begin{frame}[fragile]{\currenttitle}
  \lstinputlisting[language=C++,numbers=left,numbersep=8pt,%
                   firstline=10]{\subdir/43-utf8.cpp}

  \vspace*{1em}

  The result:

  \input{\subdir/43-utf8.Rnw_tex}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{UTF-16}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Unicode's shortcomings}
\begin{frame}{\currenttitle}
\end{frame}

% -----------------------------------------------

\end{document}
