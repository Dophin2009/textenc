% -----------------------------------------------
% chktex-file 44
\documentclass[../index.tex]{subfiles}

% -----------------------------------------------

\begin{document}

% -----------------------------------------------
\renewcommand{\sectiontitle}{Unicode}
\section{\sectiontitle}
% I hope you found ASCII pretty simple, because it's only going to get more complicated from
% here on out.
%
% Why's that?
% Because language is complicated.

% ---------------------------
\renewcommand{\currenttitle}{The problems with ASCII}
\begin{frame}{\currenttitle}
% Let's review the problems with ASCII again.
% Knowing these shortcomings will help us understand how and why Unicode is designed the way
% it is.
%
% The original ASCII character set only supported the basic English alphabet, the ten Arabic
% numeral digits, some punctuations symbols, and some other unreadable symbols.
% As we've mentioned before, this isn't really going to cut it once you move outside of English.
%
% The extended ASCII character sets like Latin 1 tried to help this, but then we have many
% different widely adopted but largely incompatible character sets.
% When you're transforming data across the globe into different systems using different
% character sets and encodings, this is going to be a problem.
%
% And as we'll see in a brief examination of other languages, the terminology and design
% behind ASCII is too na√Øve to support many kinds of languages.
  Let's review: \\

  \begin{itemize}
    \item[--] Minimal language support
    \item[--] Variants that are widespread but incompatible
    \item[--] Too na√Øve for many types of languages
  \end{itemize}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Even more precise terminology}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{How does Unicode define `character'?}
\begin{frame}{\currenttitle}
  ``The smallest component of written language that has semantic value; refers to the
    abstract meaning and/or shape, rather than a specific shape\ldots''
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The Universal Character Set}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{The seventeen Unicode planes}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Unicode encodings}
\begin{frame}{\currenttitle}
% Remember that Unicode defines the coded character set by assigning each character
% a codepoint.
% It doesn't specify which encoding you have to use to store these characters.
%
% The standard defines a few encodings, the most common of which are UTF-8 and UTF-16.
%
% The majority of websites are now encoded in UTF-8, and if you use a Unix-based system
% like Linux or macOS, the default encoding is UTF-8.
% For many modern programming languages, the encoding used internally for strings is UTF-8.
% In Rust, every string is handled internally as valid UTF-8.
%
% If you use Microsoft Windows, the default internal encoding is UTF-16.
% Java stores strings as UTF-16 internally.
%
% Of these, you should care the most about UTF-8. It's avoids complications found in
% UTF-16 and UTF-32 and is the most widely used encoding.
% The Web Hypertext Application Technology Working Group considers UTF-8 to be
% best practice and states that any browser application should not use UTF-16.
%
% So, we're going to focus primarily on UTF-8 and discuss UTF-16 briefly at the end.
  The Unicode standard defines a number of encoding formats:

  \begin{itemize}
    \item \textbf{UTF-8} \textendash{} 8-bit Unicode Transformation Format
    \item[] UTF-16LE \textendash{} 16-bit Unicode Transformation Format LE
    \item[] UTF-16BE \textendash{} UTF-16LE, but big-endian
    \item[] UTF-32LE \textendash{} 32-bit Unicode Transformation Format LE
    \item[] UTF-32BE \textendash{} UTF-32LE, but big-endian
  \end{itemize}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Examining UTF-8 encoding}
\begin{frame}{\currenttitle}
% Let's examine how characters are encoded and decoded to and from UTF-8.
%
% UTF-8 is a variable-width encoding, meaning each codepoint can take up a variable
% number of bytes.
% In the case of UTF-8, each codepoint is stored as in 1, 2, 3, or 4 bytes.
% 4 bytes is enough to store every single character in the Universal Character Set.
  UTF-8 is a \textbf{variable-width} encoding \\
  \vspace*{1em}
  Each codepoint is stored in \textbf{1 \textendash{} 4 bytes}

  \vspace*{1em}

  \begin{table}
    \begin{tabular}{c c c}
      Character & Codepoint   & Bytes required  \\ \hline
      \$        & \hex{0024}  & 1               \\
      ¬¢         & \hex{00A2}  & 2               \\
      ‚Ç¨         & \hex{20AC}  & 3               \\
      êçà         & \hex{10348} & 4
    \end{tabular}
    \caption{Number of bytes required to store certain characters}
  \end{table}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Writing a UTF-8 decoder}
\newcommand{\decoderheaderlisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   firstline=#1,lastline=#2]{%
    \codedir/utf8-decoder.hpp}%
}
\begin{frame}{\currenttitle}
% Let's write a UTF-8 decoder in C++. Don't worry if you don't know any C++, I'll walk through
% most of the code.
%
% We'll write a function convert a vector of UTF-8 encoded bytes into a vector of Unicode
% codepoints.
%
% Note that we won't be preforming any validation, so this is far from production-ready.
% We're simply assuming that the bytes are proper UTF-8.
%
% Here's part of our header file, where we'll define the function signatures and some constants.
%
% This is probably not a good practice, but we're going to alias unsigned char to a type called
% byte, and unsigned int to a type called codepoint.
% In C and C++, chars are 8-bit integers, and unsigned indicates that these values will always
% be positive.
% Thus, a byte, which we've defined as unsigned char, will simply be an 8-bit integer, representing
% an actual byte.
% Ints are 32-bit integers, so unsigned int denotes a positive 32-bit integer.
%
% We've given these names to make it clear that we're converting from a vectory of bytes to a
% vector of codepoints.
  Let's write a UTF-8 decoder in C++ \\

  We'll convert a vector of bytes into Unicode codepoints \\

  \vspace*{2em}

  Our header file:

  \decoderheaderlisting{4}{7}
\end{frame}

% ---------------------------
% Here are the functions we'll be implementing.
%
% Let's look at the second one first.
% If you've ever written Java or any other C-family language, you'll probably realize that
% we've define the function 'decode' that takes in a vector of bytes, of unsigned 8-bit
% integers.
%
% A vector is similar to the ArrayList in Java and list in Python. It's simply a growable,
% ordered container of values.
%
% const lets us know that this function won't be modifying the vector that's passed in.
%
% And vector<codepoint> indicates that the function is returning a vector of codepoints,
% a vector of 32-bit unsigned integers.
%
% 'decode' will be the main function that we call to decode UTF-8 encoded bytes.
%
% Now let's look at the second one. This is a sort of auxilliary function that will help
% 'decode' perform its logic.
%
% We pass in an iterator to a vector of bytes and step through it until we've decoded a
% single codepoint. It'll modify the location of the iterator.
% 'end' is another iterator to the same vector that will tell us inside 'next_codepoint'
% if we've reached the end of the vector and there are no more bytes to process.
%
% 'next_codepoint' is going to return an optional, which is a sum type that contains a
% value or contains null. Think of it as something or nothing.
% We're returning either a codepoint, or we're returning nothing if we're in the middle
% of decoding an codepoint and we run out of bytes to process.
%
% Don't worry too much about some of the other details.
\begin{frame}{\currenttitle}
  Our function signatures:

  \decoderheaderlisting{1}{2}
  \decoderheaderlisting{14}{18}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Here are constants we'll use in 'next_codepoint'. We'll refer back to these later.
  Byte mask constants we'll use to help process each byte:

  \decoderheaderlisting{9}{12}
\end{frame}

% ---------------------------
\newcommand{\decodercodelisting}[2]{%
  \lstinputlisting[language=C++,captionpos=b,%
                   firstline=#1,lastline=#2]{%
    \codedir/utf8-decoder.cpp}%
}
\begin{frame}{\currenttitle}
% We'll start by implementing 'next_codepoint'.
% We'll be mutating the 'iter' iterator by consuming one or more bytes and converting
% it into an integer.
%
% Here we're first checking if we've already reached the end of the bytes.
% If so, we return an empty optional.
% Remember that the optional is like 'something' or 'nothing'.
% In this case, it's nothing.
  \decodercodelisting{8}{13}
\end{frame}

% ---------------------------
\begin{frame}{\currenttitle}
% Let's start by handling the case where the next codepoint can be stored in a single
% byte.
% These are codepoints with values less than 128.
  \decodercodelisting{15}{21}
\end{frame}

% ---------------------------
\begin{frame}[fragile]{\currenttitle}
  \lstinputlisting[language=C++,firstline=10]{\subdir/43-utf8.cpp}

  \vspace*{1em}

  The result:

  \input{\subdir/43-utf8.Rnw_tex}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{UTF-16}
\begin{frame}{\currenttitle}
\end{frame}

% ---------------------------
\renewcommand{\currenttitle}{Unicode's shortcomings}
\begin{frame}{\currenttitle}
\end{frame}

% -----------------------------------------------

\end{document}
